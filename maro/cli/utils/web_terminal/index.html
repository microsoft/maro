<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <title>MARO Admin Web UI</title>
  <link rel="stylesheet" href="assets/css/xterm.css" />
  <link rel="shortcut icon" href="assets/images/favicon.ico" />
  <link rel="stylesheet" href="https://unpkg.com/element-ui@2.15.1/lib/theme-chalk/index.css">
</head>

<body>
  <style>
    .mydashboard {
      width: 100%;
      height: calc(100vh - 60px - 340px - 20px);
      border-width: 0px;
    }

    .el-header {
      line-height: 60px;
    }

    .el-main {
      padding: 0px 20px;
    }

    body {
      background: #2e2e2e;
      color: #ffffff80;
    }

    .cur_tab {
      background: white;
    }

    .text_usage_block {
      border-width: 2px;
      border: #2e2e2e;
      width: 9%;
      height: 300px;
    }

    .text_usage_image {
      line-height: 100px;
    }

    .text_usage_text {
      line-height: 100px;
    }
    
    .axis{
      fill:none;
    }
  </style>

  <el-container id="app">
    <el-header>
      <el-row>
        <el-col :span="4" style="color: #ffffff80;">
          MARO Admin Web UI
        </el-col>
        <el-col :span="20" style="text-align: right; font-size: 12px">
          <el-link type="primary" href="https://www.github.com/microsoft/maro" target="blank">
            Multi-Agent Resource Optimization
          </el-link>
          <el-link type="primary" href="https://maro.readthedocs.io/en/latest/" target="blank">
            Documentation
          </el-link>
        </el-col>
      </el-row>
    </el-header>
    <el-main>
      <el-container class="mydashboard">
        <el-main style="width: 11%;">
          <div v-for="item in cluster_list" :key="item" style="width: max-content;">
            <div :class="test_tab_type(item)" v-on:click="show_cluster(item)">{{ item }}</div>
          </div>
        </el-main>
        <el-main style="width: 33%;">
          <el-container v-if="connected">
            <el-header>
              static resource
            </el-header>
            <el-main>
              <el-container>
                <el-main class="text_usage_block">
                  <el-container>
                    <el-header class="text_usage_image">
                      <img src="assets/images/cpu.jpg" />
                    </el-header>
                    <el-main class="text_usage_text">
                      {{resource_static["cpu"]}}
                    </el-main>
                    <el-main class="text_usage_text">
                      CPU
                    </el-main>
                  </el-container>
                </el-main>

                <el-main class="text_usage_block">
                  <el-container>
                    <el-header class="text_usage_image">
                      <img src="assets/images/memory.jpg" />
                    </el-header>
                    <el-main class="text_usage_text">
                      {{resource_static["memory"]}}
                    </el-main>
                    <el-main class="text_usage_text">
                      Memory
                    </el-main>
                  </el-container>
                </el-main>

                <el-main class="text_usage_block">
                  <el-container>
                    <el-header class="text_usage_image">
                      <img src="assets/images/gpu.jpg" />
                    </el-header>
                    <el-main class="text_usage_text">
                      {{resource_static["gpu"]}}
                    </el-main>
                    <el-main class="text_usage_text">
                      GPU
                    </el-main>
                  </el-container>
                </el-main>
              </el-container>
            </el-main>
            <el-main>
              <el-container>
                <el-header>
                  dynamic resource
                </el-header>
                <el-main>
                  <el-container v-if="dashboard_type=='process'">
                    <el-header>
                    </el-header>
                    <el-main>
                      CPU:
                      <div id="cpu_chart"></div>
                    </el-main>
                    <el-main>
                      Memory:
                      <div id="memory_chart"></div>
                    </el-main>
                    <el-main>
                      GPU:
                      <div id="gpu_chart"></div>
                    </el-main>
                  </el-container>
                  <el-container v-else>
                    <el-main>
                      CPU:{{resource_dynamic["cpu"]}}
                    </el-main>
                    <el-main>
                      Memory:{{resource_dynamic["memory"]}}
                    </el-main>
                    <el-main>
                      GPU:{{resource_dynamic["gpu"]}}
                    </el-main>
                  </el-container>
                </el-main>
              </el-container>
            </el-main>
          </el-container>
        </el-main>
        <el-main style="width: 55%;">
          <el-container v-if="connected">
            <el-header>
              running jobs
            </el-header>
            <el-main v-for="job_detail in job_running">
              {{job_detail.name}}
            </el-main>
          </el-container>

          <el-container v-if="connected">
            <el-header>
              pending jobs
            </el-header>
            <el-main v-for="job_detail in job_pending">
              {{job_detail.name}}
            </el-main>
          </el-container>

          <el-container v-if="connected">
            <el-header>
              killed jobs
            </el-header>
            <el-main v-for="job_detail in job_killed">
              {{job_detail.name}}
            </el-main>
          </el-container>

          <el-container v-if="connected">
            <el-header>
              finish jobs
            </el-header>
            <el-main v-for="job_detail in job_finish">
              {{job_detail.name}}
            </el-main>
          </el-container>

          <el-container v-if="connected">
            <el-header>
              failed jobs
            </el-header>
            <el-main v-for="job_detail in job_failed">
              {{job_detail.name}}
            </el-main>
          </el-container>
        </el-main>
      </el-container>

    </el-main>
    <el-footer style="height:340px;">
      <div id="terminal"></div>
    </el-footer>
  </el-container>

  <script src="assets/js/jquery.3.5.1.min.js"></script>
  <!-- Notes: Please keep all xterm.js related package version to 3.6.0 or will be connect failed.-->
  <script src="https://unpkg.com/xterm@3.6.0/dist/xterm.js"></script>
  <script src="https://unpkg.com/xterm@3.6.0/dist/addons/fit/fit.js"></script>
  <script src="https://unpkg.com/xterm@3.6.0/dist/addons/webLinks/webLinks.js"></script>
  <script src="https://unpkg.com/xterm@3.6.0/dist/addons/fullscreen/fullscreen.js"></script>
  <script src="https://unpkg.com/xterm@3.6.0/dist/addons/search/search.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.1.1/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.12/vue.js"></script>
  <script src="https://unpkg.com/element-ui@2.15.1/lib/index.js"></script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script>
    $(document).ready(function () {
      let connected = false
      let cur_tab = undefined

      const vm = new Vue({
        el: '#app',
        data: function () {
          return {
            cluster_list: new Array(),
            cluster_name: undefined,
            dashboard_type: "",
            connected: false,
            resource_static: {
              "cpu": NaN,
              "memory": NaN,
              "gpu": NaN
            },
            resource_dynamic: {
              "cpu": new Array(),
              "memory": new Array(),
              "gpu": new Array()
            },
            job_running: new Array(),
            job_pending: new Array(),
            job_killed: new Array(),
            job_finish: new Array(),
            job_failed: new Array(),
          }
        },
        methods: {
          show_cluster: function (message) {
            if (cur_tab != undefined)
            {
              clearInterval(cur_tab);
            }
            cur_tab = setInterval(() => {
              if (connected) {
                socket.emit('cluster_status', { cluster_name: message })
              }
            }, 1000)
          },
          test_tab_type: function (item_type) {
            if (item_type == this.cluster_name) {
              return "cur_tab";
            }
            else {
              return "normal_tab";
            }
          }
        }
      })
      setInterval(() => {
        if (connected) {
          socket.emit("cluster_list")
        }
      }, 1000)

      // Load terminal addons.
      Terminal.applyAddon(fullscreen)
      Terminal.applyAddon(fit)
      Terminal.applyAddon(webLinks)
      Terminal.applyAddon(search)

      // Create xterms.js terminal.
      const waitMS = 50
      const term = new Terminal({
        cols: 1,
        rows: 20,
        cursorBlink: true,
        macOptionIsMeta: true,
        scrollback: true
      })



      term.open(document.getElementById('terminal'))
      term.fit()

      term.on('key', (key, ev) => {
        socket.emit('pty-input', { input: key })
      })
      term.on('paste', function (text) {
        socket.emit('pty-input', { input: text })
      })

      term.prompt = (content) => {
        socket.emit('pty-input', { input: content })
      }

      // Create socket.io connection.
      const socket = io.connect('/pty')

      socket.on('pty-output', function (data) {
        console.log('new output', data)
        term.write(data.output)
      })

      socket.on('connect', () => {
        console.log('socket.io connected.')
        connected = true
      })

      socket.on('disconnect', () => {
        console.log('socket.io disconnected.')
        connected = false
      })

      socket.on("cluster_list", (data) => {
        // console.log(data)
        vm.cluster_list = data
      })

      socket.on("cluster_status", (data) => {
        console.log(data)
        if (data != undefined) {
          vm.connected = true
          vm.cluster_name = data["cluster_name"]
          vm.dashboard_type = data["dashboard_type"]
          vm.resource_static = data["resource_static"]
          vm.resource_dynamic = data["resource_dynamic"]
          job_running = new Array()
          job_pending = new Array()
          job_killed = new Array()
          job_finish = new Array()
          job_failed = new Array()
          data["job_detail_data"].forEach(job_detail => {
            switch (job_detail["status"]) {
              case "running": job_running.push(job_detail); break;
              case "pending": job_pending.push(job_detail); break;
              case "killed": job_killed.push(job_detail); break;
              case "finish": job_finish.push(job_detail); break;
              case "failed": job_failed.push(job_detail); break;
              default: break;
            }
          });
          vm.job_running = job_running
          vm.job_pending = job_pending
          vm.job_killed = job_killed
          vm.job_finish = job_finish
          vm.job_failed = job_failed

          if(vm.dashboard_type == "process")
          {
            draw_chart("cpu_chart", vm.resource_dynamic["cpu"])
            draw_chart("memory_chart", vm.resource_dynamic["memory"])
            draw_chart("gpu_chart", vm.resource_dynamic["gpu"])
          }
        }
        else {
          console.log("Can not get cluster status form server. Maybe cluster name issue or cluster shut down")
          vm.connected = false
        }
      })

      function fitToScreen() {
        term.fit()
        socket.emit('resize', { cols: term.cols, rows: term.rows })
      }

      function terminalResize(func, waitMS) {
        let timeout
        return function (...args) {
          const context = this
          clearTimeout(timeout)
          timeout = setTimeout(() => func.apply(context, args), waitMS)
        }
      }

      function draw_chart(chart_id, chart_data) {
        function gen_color(specifier) {
          let n = specifier.length / 6 | 0,
            colors = new Array(n),
            i = 0;
          while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
          return colors;
        }

        let default_color = gen_color("97b7eeffc05993d586da393cf99841");
        let color = d3.scaleOrdinal(default_color);

        let chart_width = 300;
        let chart_height = 150;
        let chart_margin = {
          left: 30,
          top: 10,
          right: 10,
          bottom: 20,
        };
        d3.select("#" + chart_id)
          .selectAll("*")
          .remove();
        var chart_root = d3
          .select("#" + chart_id)
          .style("width", "90%")
          .append("svg")
          .attr("viewBox", "0,0," + chart_width + "," + chart_height)
          .append("g")
          .attr("transform", "translate(" + chart_margin.left + "," + chart_margin.top + ")");

        let x_min = Number.MAX_VALUE;
        let x_max = 0;
        let y_min = 0;
        let y_max = 100;
        let width = chart_width - chart_margin.left - chart_margin.right;
        let height = chart_height - chart_margin.top - chart_margin.bottom;

        let render_data = [];
        for( let i=0;i<chart_data.length;i++)
        {
          let push_data = {x:i, y:chart_data[i]}
          if (push_data.x > x_max) {
            x_max = push_data.x;
          }
          if (push_data.x < x_min) {
            x_min = push_data.x;
          }
          if (push_data.y > y_max) {
            y_max = push_data.y;
          }
          if (push_data.y < y_min) {
            y_min = push_data.y;
          }
          render_data.push(push_data);
        }

        let x = d3.scaleLinear().range([0, width]).domain([x_min, x_max]);
        let y = d3.scaleLinear().range([height, 0]).domain([y_min, y_max]);
        let e = chart_root.append("g");
        let line = d3
          .line()
          .defined(d => !isNaN(d.y))
          .x(function (d) {
            return x(d.x);
          })
          .y(function (d) {
            return y(d.y);
          });

        e.append("g")
          .datum(render_data)
          .append("path")
          .style("stroke-width", "1px")
          .style("stroke", color(0))
          .style("fill", "none")
          .style("pointer-events", "none")
          .attr("d", function (d) {
            return line(d);
          });
        let xAxis = d3.axisBottom().scale(x).ticks(5);
        e.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(" + 0 + "," + height + ")")
          .call(xAxis);

        let yAxis = d3.axisLeft().scale(y).ticks(5);
        e.append("g")
          .attr("class", "y axis")
          .attr("transform", "translate(" + 0 + "," + 0 + ")")
          .call(yAxis);

      }

      window.onresize = terminalResize(fitToScreen, waitMS)
      term.write('Welcome to MARO.\r\n')
      term.write('Repository: https://github.com/microsoft/maro\r\n')
      term.write('Documentation: https://maro.readthedocs.io/en/latest/\r\n')
      term.prompt('\n')
    })
  </script>
</body>

</html>