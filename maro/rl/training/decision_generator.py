# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

from abc import ABC, abstractmethod
from collections import defaultdict
from os import getcwd
from typing import Dict, List

from maro.communication import Proxy, SessionMessage
from maro.rl.policy import AbsPolicy
from maro.utils import Logger

from .message_enums import MsgKey, MsgTag


class AbsDecisionGenerator(ABC):
    def __init__(self, agent2policy: Dict[str, str]):
        super().__init__()
        self.agent2policy = agent2policy

    @abstractmethod
    def choose_action(self, state: dict, ep: int, step: int) -> dict:
        """Generate an action based on the given state.
        
        Args:
            state (dict): Dicitionary of agents' states based on which action decisions will be made.
            ep (int): Current episode.
            step (int): Current step.
        """
        raise NotImplementedError


class LocalDecisionGenerator(AbsDecisionGenerator):
    """Local decision generator.

    Args:
        agent2policy (Dict[str, str]): Mapping from agent ID's to policy ID's. This is used to direct an agent's
            queries to the correct policy.
        policies (List[AbsPolicy]): A list of policies for inference.
        log_dir (str): Directory to store logs in. A ``Logger`` will be created at init time and this directory
            will be used to save the log files generated by it. Defaults to the current working directory.
    """
    def __init__(self, agent2policy: Dict[str, str], policies: List[AbsPolicy], log_dir: str = getcwd()):
        super().__init__(agent2policy)
        self.policy_dict = {policy.name: policy for policy in policies}
        self.policy = {agent_id: self.policy_dict[policy_id] for agent_id, policy_id in self.agent2policy.items()}
        self._logger = Logger("local_decision_generator", dump_folder=log_dir)

    def choose_action(self, state: dict, ep: int, step: int) -> dict:
        """Generate an action based on the given state.
        
        Args:
            state (dict): Dicitionary of agents' states based on which action decisions will be made.
            ep (int): Current episode.
            step (int): Current step.
        """
        return {agent_id: self.policy[agent_id].choose_action(st) for agent_id, st in state.items()}

    def store_experiences(self, exp_by_agent: dict) -> set:
        """Store agent experiences in the policies' experience managers."""
        policies_with_new_exp = set()
        for agent_id, exp in exp_by_agent.items():
            self.policy[agent_id].experience_manager.put(exp)
            policies_with_new_exp.add(self.agent2policy[agent_id])

        return policies_with_new_exp

    def get_experiences_by_policy(self, policy_names: List[str]):
        """Get experiences by policy names."""
        return {name: self.policy_dict[name].experience_manager.get() for name in policy_names}

    def update(self, policy_state_dict: dict):
        """Update policy states."""
        for policy_id, policy_state in policy_state_dict.items():
            self.policy_dict[policy_id].set_state(policy_state)

        if policy_state_dict:
            self._logger.info(f"updated policies {list(policy_state_dict.keys())}")


class PolicyClient(AbsDecisionGenerator):
    def __init__(
        self,
        agent2policy: Dict[str, str],
        group: str,
        max_receive_attempts: int = None,
        receive_timeout: int = None,
        log_dir: str = getcwd(),
        **proxy_kwargs
    ):
        super().__init__(agent2policy)
        self._max_receive_attempts = max_receive_attempts
        self._receive_timeout = receive_timeout
        self._proxy = Proxy(group, "policy_client", {"policy_manager": 1}, **proxy_kwargs)
        self._logger = Logger(self._proxy.name, dump_folder=log_dir)

    def choose_action(self, state: dict, ep: int, step: int) -> dict:
        """Generate an action based on the given state.
        
        Args:
            state (dict): Dicitionary of agents' states based on which action decisions will be made.
            ep (int): Current episode.
            step (int): Current step.
        """
        state_by_policy_name, agent_ids_by_policy_name = defaultdict(list), defaultdict(list)
        for agent_id, st in state.items():
            policy_name = self.agent2policy[agent_id]
            state_by_policy_name[policy_name].append(st)
            agent_ids_by_policy_name[policy_name].append(agent_id)

        self._proxy.isend(
            SessionMessage(
                MsgTag.CHOOSE_ACTION, self._proxy.name, self._proxy.peers["policy_manager"][0],
                body={MsgKey.EPISODE: ep, MsgKey.STEP: step, MsgKey.STATE: dict(state_by_policy_name)}
            )
        )

        action_received = False
        for _ in range(self._max_receive_attempts):
            msg = self._proxy.receive_once(timeout=self._receive_timeout)
            if msg and msg.tag == MsgTag.ACTION and msg.body[MsgKey.EPISODE] == ep and msg.body[MsgKey.STEP] == step:
                action_received = True
                break
        
        if not action_received:
            self._logger(f"Failed to receive actions for episode {ep}, step {step}")
        else:
            action = {}
            for policy_name, action_batch in msg.body[MsgKey.ACTION].items():
                action.update(dict(zip(agent_ids_by_policy_name[policy_name], action_batch)))

        return action
